#!/usr/bin/env ruby

enable_profiler = false

# The random data source
require 'securerandom'
# The benchmarking tool
require 'benchmark'
# The profiler
require "profile" if enable_profiler
# Sintra - http front end
#~ require "sinatra"
require 'yaml'
require 'json'
require 'xmlsimple'


class RandomGenerator
    attr_accessor :charset, :min, :mix, :count, :result

    def initialize(kwargs={})
        kwargs = { charset: "", min: 0, max: 8, count: 8}.merge(kwargs)
        @charset = kwargs[:charset]
        @min = kwargs[:min]
        @max = kwargs[:max]
        @count = kwargs[:count]
    end

    def random(kwargs={})
        kwargs = { min: @min, max: @max, count: @count}.merge(kwargs)
        @result = ""
        SecureRandom.random_bytes(@max).unpack("C*").each { |a| @result += @charset[a%charset.length] }
        return @result
    end

    def to_yaml()
        @result.to_yaml
    end

    def to_xml()
        XmlSimple.xml_out(@result, :RootName => 'raas_results')
    end

    def to_json()
        JSON.pretty_generate(@result)
    end

    def to_txt()
        return @result
    end

    def to_html()
    end

end

class NumberGenerator < RandomGenerator
    def random(kwargs={})
        kwargs = { min: @min, max: @max}.merge(kwargs)
        @min = kwargs[:min]
        @max = kwargs[:max]
        r = @max - @min
        @result = ""
        @result += (SecureRandom.random_number(r)+@min).to_s
        #~ @count.times do
            #~ r_num = SecureRandom.random_number(charset.length)
            #~ @result += @charset[r_num%charset.length]
        #~ end
        return @result
    end
end

class AsciiGenerator < RandomGenerator
    def initialize(kwargs={})
        kwargs = {charset: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'}.merge(kwargs)
        super(kwargs)
    end
end

class SafeAsciiGenerator < AsciiGenerator
    def initialize(kwargs={})
        kwargs = {charset: '23456789abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ'}.merge(kwargs)
        super(charset)
    end
end

class WordGenerator < RandomGenerator
    attr_reader :fh

    def initialize(kwargs={})
        kwargs = {charset: []}.merge(kwargs)
        @fh = File.new("/usr/share/dict/cracklib-small", "r")
        @fh.each { |line| kwargs[:charset].push(line) }
        super(kwargs)
        @fh.close
    end


    def random(kwargs={})
        # max - maximum word length
        # min - minimum word length
        # count - number of words
        kwargs = { min: @min, max: @max, count: @count}.merge(kwargs)
        @result = ""
        @count.times do
            r_num = SecureRandom.random_number(charset.length)
            @result += @charset[r_num%charset.length]
        end
        return @result
    end

    def finished
        @fh.close if @fh.closed? == false
    end
end









# To do: run some speed tests using the different ways to generate the
# string data.
# Test 1 Generate a given set of strings using the "charset" method below
# Test 2 urlsafe / substitution method.
# Test n - We can also brainstorm on other ways to get the strings we want.

# SecureRandom.random_number generates 0.<numbers>
# Generate floating point, convert to string, strip off the lead '0.', and get
# the number back.


# It works, but it's nasty and we can't control the length. :(
def ran_num(q = true)
    result = SecureRandom.random_number.to_s.gsub('0.', '').to_i
    if ! q then puts "random_number, fuzzy length => #{result}" end
    return result
end

# We can specify character sets to be used.
def charset1(q = true)
    set = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    # This calls random_number generator 32 times, which generates 16 bytes of
    # random data each time. (very expensive 512 bytes for 32 random characters.)
    result = Array.new(32){set[SecureRandom.random_number(set.length)]}.join
    if ! q then puts "[a-zA-Z0-9], length 32, slow => #{result}" end
    return result
end

def charset2(q = true)
    set = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    result = ""
    # By handling the random bytes ourselves we have performance which matches
    # the native methods implemented in the SecureRandom module.
    SecureRandom.random_bytes(32).unpack("C*").each {|a| result += set[a%set.length]}
    if ! q then puts "[a-zA-Z0-9], length 32, fast => #{result}" end
    return result
end

# This is redundant given charset1
def charset3(q = true)
    set = '23456789abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ'
    result = Array.new(32){set[SecureRandom.random_number(set.length)]}.join
    if ! q then puts "[a-zA-Z0-9] except confusing chars, length 32 => #{result}" end
    return result
end

# SecureRandom.hex will generate set [a-f0-9] for us.
def hex(q = true)
    result = SecureRandom.hex(8)
    if ! q then puts "hex, length 8 => #{result}" end
    return result
end

# SecureRandom.base64 will generate set [a-zA-Z0-9\+\/\=]; this is sort of
# useful, but the weird characters are irritating...
def base64(q = true )
    result = SecureRandom.base64
    if ! q then puts "base64, fuzzy length => #{result}" end
    return result
end


# urlsafe gives us *almost* [a-zA-Z0-9], but also sometimes - and _. :(
def url_safe(q = true)
    result = SecureRandom.urlsafe_base64
    if ! q then puts "urlsafe_base64, fuzzy length => #{result}" end
    return result
end

# So we can substitute a random number for the "other" char. :P
def url_safe_subbed(q = true)
    result = SecureRandom.urlsafe_base64
    sub = SecureRandom.random_number(10).to_s
    result.gsub!(/[\-\_]/, sub)
    if ! q then puts "urlsafe_base64, fuzzy length, alphanum only => #{result}" end
    # Yes, this works, but it's hacky as hell, haha.
    return result
end


def run_benchmark
    # How many times to run each generator.
    n = 100000
    puts "Generations : #{n}"

    puts "Start : #{Time.now}"

    Benchmark.bm(15) do |x|
        x.report('hex') do
            (0..n).each { hex }
        end
        x.report('base64') do
            (0..n).each { base64 }
        end
        x.report('url_safe') do
            (0..n).each { url_safe }
        end
        x.report('url_safe_subbed') do
            (0..n).each { url_safe_subbed }
        end
        #~ x.report('charset1') do
            #~ (0..n).each { charset1 }
        #~ end
        x.report('charset2') do
            (0..n).each { charset2 }
        end
        #~ x.report('charset3') do
            #~ (0..n).each { charset3 }
        #~ end
        x.report('ran_num') do
            (0..n).each { ran_num }
        end
        x.report("class_ascci") do
            r = AsciiGenerator.new(max: 32)
            (0..n).each { r.random }
        end
        x.report("class_dictionary") do
            d = WordGenerator.new
            (0..n).each { d.random }
        end
        x.report("class_num") do
            r = NumberGenerator.new(min:50, max:50000)
            (0..n).each { r.random }
        end
    end

    puts "End : #{Time.now}"
#~
    #~ puts '', "Samples :"
    #~ hex(false)
    #~ base64(false)
    #~ url_safe(false)
    #~ url_safe_subbed(false)
    #~ charset1(false)
    #~ charset2(false)
    #~ charset3(false)
    #~ ran_num(false)
end

def routes

    get "/" do
        erb :index
    end

    post "/raas/" do
        "OK"
    end


    #~ post "/random/" do
        #~ output_select[:enc](random_select[:charset].random(:len, :num))
    #~ end

end



#run_benchmark

n=NumberGenerator.new(min: 5, max: 11, count: 100)
w=WordGenerator.new(min: 0, max: 50, count: 5)

#puts "Number #{n.random.to_yaml}"
puts "Word  #{w.random()}"

